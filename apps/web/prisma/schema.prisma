generator client {
  provider      = "prisma-client-js"
  output        = "../app/generated/prisma"
  binaryTargets = ["native", "linux-musl-openssl-3.0.x"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id                BigInt           @id @default(autoincrement())
  referenceId       String           @unique @default(cuid())
  code              String           @unique
  googleId          String           @unique
  email             String           @unique
  name              String
  profilePictureUrl String?
  dateOfBirth       DateTime?
  isActive          Boolean          @default(true)
  createdAt         DateTime         @default(now())
  updatedAt         DateTime         @updatedAt
  onboarded         Boolean          @default(false)
  dodoCustomerId    String?          @unique
  chessComProfile      ChessComProfile?
  gamesAsCreator       Game[]             @relation("CreatorGames")
  gamesAsOpponent      Game[]             @relation("OpponentGames")
  gamesWon             Game[]             @relation("WinnerGames")
  transactions         Transaction[]
  stats                UserStats?
  wallet               Wallet?
  matchmakingRequests  MatchmakingQueue[]

  @@index([googleId])
  @@index([email])
  @@index([code])
  @@index([referenceId])
  @@index([dodoCustomerId])
  @@map("users")
}

model Wallet {
  id           BigInt   @id @default(autoincrement())
  referenceId  String   @unique @default(cuid())
  userId       BigInt   @unique
  balance      Decimal  @default(0) @db.Decimal(19, 2)
  lockedAmount Decimal  @default(0) @db.Decimal(19, 2)
  updatedAt    DateTime @updatedAt
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([referenceId])
  @@map("wallets")
}

model Transaction {
  id           BigInt            @id @default(autoincrement())
  referenceId  String            @unique @default(cuid())
  userId       BigInt
  gameId       BigInt?
  type         TransactionType
  amount       Decimal           @db.Decimal(19, 2)
  balanceAfter Decimal           @db.Decimal(19, 2)
  status       TransactionStatus @default(PENDING)
  metadata     Json?
  description  String
  createdAt    DateTime          @default(now())
  game         Game?             @relation(fields: [gameId], references: [id])
  user         User              @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([gameId])
  @@index([createdAt])
  @@index([status])
  @@index([referenceId])
  @@map("transactions")
}

model Game {
  id                    BigInt        @id @default(autoincrement())
  referenceId           String        @unique @default(cuid())
  creatorId             BigInt
  opponentId            BigInt?
  stakeAmount           Decimal       @db.Decimal(19, 2)
  totalPot              Decimal       @db.Decimal(19, 2)
  platformFeePercentage Decimal       @db.Decimal(5, 2)
  platformFeeAmount     Decimal       @db.Decimal(19, 2)
  status                GameStatus    @default(WAITING_FOR_OPPONENT)
  result                GameResult?
  winnerId              BigInt?
  chessPositionId       BigInt?
  startingFen           String
  initialTimeSeconds    Int
  incrementSeconds      Int
  creatorTimeRemaining  Int
  opponentTimeRemaining Int
  lastMoveAt            DateTime?
  gameData              Json?
  expiresAt             DateTime
  startedAt             DateTime?
  completedAt           DateTime?
  createdAt             DateTime      @default(now())
  updatedAt             DateTime      @updatedAt
  creator               User          @relation("CreatorGames", fields: [creatorId], references: [id], onDelete: Cascade)
  opponent              User?         @relation("OpponentGames", fields: [opponentId], references: [id], onDelete: Cascade)
  winner                User?         @relation("WinnerGames", fields: [winnerId], references: [id])
  transactions          Transaction[]

  @@index([creatorId])
  @@index([opponentId])
  @@index([winnerId])
  @@index([status])
  @@index([expiresAt])
  @@index([referenceId])
  @@index([chessPositionId])
  @@map("games")
}

model UserStats {
  id                    BigInt    @id @default(autoincrement())
  referenceId           String    @unique @default(cuid())
  userId                BigInt    @unique
  totalGamesPlayed      Int       @default(0)
  gamesWon              Int       @default(0)
  gamesLost             Int       @default(0)
  gamesDrawn            Int       @default(0)
  totalMoneyWon         Decimal   @default(0) @db.Decimal(19, 2)
  totalMoneyLost        Decimal   @default(0) @db.Decimal(19, 2)
  totalPlatformFeesPaid Decimal   @default(0) @db.Decimal(19, 2)
  netProfit             Decimal   @default(0) @db.Decimal(19, 2)
  currentWinStreak      Int       @default(0)
  longestWinStreak      Int       @default(0)
  averageGameDuration   Int?
  lastPlayedAt          DateTime?
  updatedAt             DateTime  @updatedAt
  user                  User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([referenceId])
  @@map("user_stats")
}

model ChessComProfile {
  id               BigInt   @id @default(autoincrement())
  referenceId      String   @unique @default(cuid())
  userId           BigInt   @unique
  chessComHandle   String   @unique
  displayName      String?
  avatar           String?
  title            String?
  country          String?
  status           String?
  followers        Int?
  isStreamer       Boolean  @default(false)
  joined           DateTime?
  rapidRating      Int?
  rapidBestRating  Int?
  rapidWins        Int?
  rapidLosses      Int?
  rapidDraws       Int?
  blitzRating      Int?
  blitzBestRating  Int?
  blitzWins        Int?
  blitzLosses      Int?
  blitzDraws       Int?
  bulletRating     Int?
  bulletBestRating Int?
  bulletWins       Int?
  bulletLosses     Int?
  bulletDraws      Int?
  dailyRating      Int?
  dailyBestRating  Int?
  dailyWins        Int?
  dailyLosses      Int?
  dailyDraws       Int?
  lastSyncedAt     DateTime @default(now())
  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt
  user             User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([chessComHandle])
  @@index([referenceId])
  @@map("chess_com_profiles")
}

model ChessPosition {
  id          BigInt @id @default(autoincrement())
  referenceId String @unique @default(cuid())

  // ===== REQUIRED FIELDS (Minimum data needed) =====
  fen        String @unique
  sideToMove String

  // ===== OPTIONAL CORE DATA =====
  pgn        String?
  moveNumber Int?

  // ===== PLAYER INFO (All nullable) =====
  whitePlayerName     String?
  blackPlayerName     String?
  whitePlayerMetadata Json?
  blackPlayerMetadata Json?
  whitePlayerId       BigInt? // FK to Legend if white player is a legend
  blackPlayerId       BigInt? // FK to Legend if black player is a legend

  // ===== GAME METADATA (All nullable) =====
  tournamentName String?
  eventDate      DateTime?
  gameMetadata   Json?

  // ===== POSITION INFO (Optional but recommended) =====
  positionType    String?
  positionContext Json?

  // ===== SOURCE (Track where it came from) =====
  sourceType     String @default("manual")
  sourceMetadata Json?

  // ===== ENGAGEMENT & SYSTEM =====
  timesPlayed     Int      @default(0)
  popularityScore Float?
  featured        Boolean  @default(false)
  isActive        Boolean  @default(true)
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  // Relations
  whiteLegend Legend? @relation("WhiteLegendGames", fields: [whitePlayerId], references: [id], onDelete: SetNull)
  blackLegend Legend? @relation("BlackLegendGames", fields: [blackPlayerId], references: [id], onDelete: SetNull)

  @@index([referenceId])
  @@index([sourceType])
  @@index([featured])
  @@index([isActive])
  @@index([whitePlayerId])
  @@index([blackPlayerId])
  @@map("chess_positions")
}

model Legend {
  id          BigInt @id @default(autoincrement())
  referenceId String @unique @default(cuid())

  // ===== BASIC INFORMATION =====
  name String @unique // Full name (e.g., "Magnus Carlsen")
  era  String // Chess era (e.g., "Modern Era", "Romantic Era")

  // ===== VISUAL & DISPLAY =====
  profilePhotoUrl String? // URL to profile image

  // ===== CHESS STATS =====
  peakRating  Int?    // Peak ELO rating
  nationality String? // Country code (e.g., "NOR", "USA")

  // ===== DESCRIPTIONS =====
  shortDescription String  @db.VarChar(500) // 1-2 sentences for cards
  playingStyle     String? // Description of their style

  // ===== ADDITIONAL INFO =====
  birthYear Int?
  deathYear Int? // Null if still alive

  // ===== METADATA AS JSON =====
  achievements Json? // Array of major titles/achievements
  famousGames  Json? // Array of notable games with FEN positions

  // ===== ADMIN & ANALYTICS =====
  isActive  Boolean @default(true) // Record is active in system
  isVisible Boolean @default(false) // Show/hide on UI

  // ===== TIMESTAMPS =====
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations - Games where this legend played
  gamesAsWhite ChessPosition[] @relation("WhiteLegendGames")
  gamesAsBlack ChessPosition[] @relation("BlackLegendGames")

  @@index([name])
  @@index([isActive])
  @@map("legends")
}

model Opening {
  id          BigInt   @id @default(autoincrement())
  referenceId String   @unique @default(cuid())

  eco        String   // ECO code e.g. "A00", "C50"
  name       String   // Full name e.g. "Italian Game: Giuoco Piano"
  pgn        String   // PGN moves e.g. "1. e4 e5 2. Nf3 Nc6 3. Bc4 Bc5"
  fen        String   // FEN after PGN moves played out
  sideToMove String   // "white" or "black" â€” whose turn after PGN
  moveCount  Int      // Number of half-moves (plies)

  isActive  Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([eco])
  @@index([name])
  @@unique([eco, name, pgn])
  @@index([isActive])
  @@map("openings")
}

enum TransactionType {
  DEPOSIT
  WITHDRAWAL
  GAME_STAKE
  GAME_WIN
  GAME_DRAW_REFUND
  PLATFORM_FEE
  GAME_EXPIRED_REFUND
}

enum TransactionStatus {
  PENDING
  COMPLETED
  FAILED
}

enum GameStatus {
  WAITING_FOR_OPPONENT
  IN_PROGRESS
  COMPLETED
  CANCELLED
  EXPIRED
}

enum GameResult {
  CREATOR_WON
  OPPONENT_WON
  DRAW
  CREATOR_TIMEOUT
  OPPONENT_TIMEOUT
}

enum MatchmakingStatus {
  SEARCHING
  MATCHED
  CANCELLED
  EXPIRED
}

model MatchmakingQueue {
  id          BigInt @id @default(autoincrement())
  referenceId String @unique @default(cuid())

  // Player info
  userId          BigInt
  rating          Int?   // Player's rating for this time control (from ChessComProfile)
  timeControlType String // "bullet", "blitz", "rapid", "daily"

  // Game preferences
  legendReferenceId  String? // Legend.referenceId (no FK - just stored for position lookup)
  openingReferenceId String? // Opening.referenceId (no FK - just stored for position lookup)
  timeControlSeconds Int     // e.g., 300 for 5 min
  incrementSeconds   Int     // e.g., 5

  // Queue state
  status MatchmakingStatus @default(SEARCHING)

  // Timing
  createdAt DateTime  @default(now())
  expiresAt DateTime  // createdAt + 60 seconds
  matchedAt DateTime?

  // If matched, store game reference ID (no FK - just for returning to client)
  matchedGameRef String? // Game.referenceId when matched

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([status, timeControlSeconds, incrementSeconds, rating])
  @@index([expiresAt])
  @@map("matchmaking_queue")
}
